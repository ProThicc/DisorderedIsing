# -*- coding: utf-8 -*-
"""Many-body Dis_ising-version1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19TQ0Fo8zmo626dLhi_P2QOuMDEXumIp2
"""

# !pip install qiskit

import numpy as np
import matplotlib.pyplot as plt
from quimb import *
from scipy import sparse
from quimb.linalg.base_linalg import *
from qiskit import QuantumCircuit
from qiskit import Aer, transpile
from qiskit.circuit import Parameter
from qiskit.visualization import plot_histogram
from scipy.linalg import expm
from qiskit.quantum_info import Operator
N = 12 #Number of qubits

J = np.zeros((N,N))
for i in range(N-1):
    J[i,i+1] = np.random.choice([-1, 1])
# J[0, 1] = 1
# J[1, 2] = -1
# J[2, 3] = -1

print(J)

I, X, Y, Z = (pauli(s) for s in 'IXYZ')

def dis_ising(J,N):
    M = 2**N # DImension of hilbert space
    H = np.zeros((M,M))
    for i in range(N-1):
        H = H + J[i,i+1]*ikron(Z,dims = [2]*N,inds = [i,i+1])
    return H

H = dis_ising(J, N)
# U = expm(H*dt)

gs = groundstate(H)
# print(gs)
# test_state = kron(up(), down(), up(), up())
# print(expec(test_state, H))

m = np.zeros((N))
for i in range(N):
  rho_red = ptr(gs,dims = [2]*N, keep = i)
  m[i] = expec(Z,rho_red)
print(m)

print("Lowest energy from exact Diagonalisation is = ", expec(H,gs))

T = 1*np.pi         #final time
L = 1500          #number of time steps
# iter = L           #number of iterations

ts = np.linspace(0, T, L)

def scaling(x):
    return x**2 #Linear Scaling

def a(t):
    a = scaling(t)
    return a

def b(t):
    b = 1 - scaling(t)
    return b

dt = T/L


qc = QuantumCircuit(N)
for qubit in range(0, N): # creating uniform superposition
    qc.h(qubit)

# dt = Parameter('dt')

for k in range(L):
    # U = expm(-1j * a(k/L) * H * dt)
    # U = Operator(U)
    for i in range(N-2, -1, -1):
        j = i+1
        qc.rzz(-np.pi * a(k/L) * J[i, j] * dt, j, i)
        # print('j, i: ', j, i)
        # qc.cnot(i, i+1)
        # qc.rz(2 * a(k/L) * dt * J[i, i+1], i+1)
        # qc.cnot(i, i+1)
    # qc.append(U, [0, 1, 2, 3])

    for i in range(0, N):      # H_D = uniform X field
        qc.rx(np.pi * b(k/L) * dt, i)

qc.measure_all()
# print(qc)
# q_circs = [qc.assign_parameters({dt: a}, inplace=False) for a in ts]
num_shots_per_point = 4000

sim = Aer.get_backend('aer_simulator')
t_qc = transpile(qc, sim)
counts = sim.run(t_qc, shots=num_shots_per_point).result().get_counts()
print(counts)

expectation_z = 0
for key in counts:
    bitstring = key
    # bitstring.reverse()
    # print(bitstring)
    print(key)
    for m in range(N-1, 0, -1):
        # l = m+1
        # print(m, l)
        expectation_z += J[N-m-1, N-m]*(int(counts[key]) * (-1) ** (int(bitstring[m-1]) + int(bitstring[m])))
        print('m, l ', int(bitstring[m]), int(bitstring[m-1]))
        print(J[m-1, m])
expectation_z = expectation_z / num_shots_per_point

print('<H>: ', expectation_z)
plot_histogram(counts)
plt.tight_layout()
plt.show()
# plt.plot(ts, exp)
# plt.title("Disordered Ising Model")
# plt.xlabel('Time')
# plt.ylabel('Expectation value of H')
# plt.show()















